import numpy
from .base_anvil_interface import BaseAnvilInterface as BaseAnvilInterface, ChunkDataType as ChunkDataType, ChunkPathType as ChunkPathType
from _typeshed import Incomplete
from amulet.api.chunk import Chunk as Chunk, StatusFormats as StatusFormats
from amulet.api.data_types import AnyNDArray as AnyNDArray, BlockCoordinates as BlockCoordinates, SubChunkNDArray as SubChunkNDArray
from amulet.api.wrapper import EntityCoordType as EntityCoordType, EntityIDType as EntityIDType
from amulet.utils import world_utils as world_utils
from amulet_nbt import CompoundTag, ListTag
from typing import Dict, Iterator, Tuple

log: Incomplete

class AnvilNAInterface(BaseAnvilInterface):
    Level: ChunkPathType
    Sections: ChunkPathType
    BlockEntities: ChunkPathType
    Entities: ChunkPathType
    InhabitedTime: ChunkPathType
    LastUpdate: ChunkPathType
    HeightMap: ChunkPathType
    TerrainPopulated: ChunkPathType
    LightPopulated: ChunkPathType
    V: ChunkPathType
    BlockTicks: ChunkPathType
    Biomes: ChunkPathType
    xPos: ChunkPathType
    zPos: ChunkPathType
    def __init__(self) -> None: ...
    @staticmethod
    def minor_is_valid(key: int): ...
    def decode(self, cx: int, cz: int, data: ChunkDataType, bounds: Tuple[int, int]) -> Tuple['Chunk', AnyNDArray]: ...
    def _get_floor_cy(self, data: ChunkDataType): ...
    @staticmethod
    def _init_decode(cx: int, cz: int, data: ChunkDataType) -> Chunk:
        """Get the decode started by creating a chunk object."""
    def _get_level(self, data: ChunkDataType) -> CompoundTag:
        """
        Get the level data container
        For older levels this is region:Level but newer worlds it is in region root
        :param data: The raw chunk data
        :return: The level data compound
        """
    def _decode_coords(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_last_update(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_status(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_v_tag(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_inhabited_time(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_biomes(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_height(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _iter_sections(self, data: ChunkDataType) -> Iterator[Tuple[int, CompoundTag]]: ...
    def _decode_blocks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _unpack_light(self, data: ChunkDataType, section_key: str) -> Dict[int, numpy.ndarray]: ...
    def _decode_block_light(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_sky_light(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_entities(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_block_entities(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    @staticmethod
    def _decode_ticks(ticks: ListTag) -> Dict[BlockCoordinates, Tuple[str, int, int]]: ...
    def _decode_block_ticks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def encode(self, chunk: Chunk, palette: AnyNDArray, max_world_version: Tuple[str, int], bounds: Tuple[int, int]) -> ChunkDataType: ...
    def _init_encode(self, chunk: Chunk, max_world_version: Tuple[str, int], floor_cy: int, height_cy: int) -> ChunkDataType:
        """Get or create the root data."""
    def _get_encode_sections(self, data: ChunkDataType, floor_cy: int, height_cy: int) -> Dict[int, CompoundTag]:
        """Get or create the section array populating all valid sections"""
    def _encode_block_section(self, chunk: Chunk, sections: Dict[int, CompoundTag], palette: AnyNDArray, cy: int): ...
    def _encode_blocks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_coords(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_last_update(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_status(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_v_tag(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_inhabited_time(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_biomes(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_height(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_entities(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_block_entities(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    @staticmethod
    def _encode_ticks(ticks: Dict[BlockCoordinates, Tuple[str, int, int]]) -> ListTag: ...
    def _encode_block_ticks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _pack_light(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int, feature_key: str, section_key: str): ...
    def _encode_block_light(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_sky_light(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _post_encode_sections(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int):
        """Strip out all empty sections"""
export = AnvilNAInterface
