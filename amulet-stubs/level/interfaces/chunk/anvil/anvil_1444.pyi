import numpy
from .anvil_0 import Anvil0Interface as ParentInterface
from .base_anvil_interface import ChunkDataType as ChunkDataType, ChunkPathType as ChunkPathType
from _typeshed import Incomplete
from amulet.api.chunk import Chunk as Chunk, StatusFormats as StatusFormats
from amulet.api.data_types import AnyNDArray as AnyNDArray, BlockCoordinates as BlockCoordinates
from amulet.block import Block as Block
from amulet.utils.world_utils import decode_long_array as decode_long_array, encode_long_array as encode_long_array
from amulet_nbt import CompoundTag, ListTag
from typing import Dict, Iterable, Optional, Set, Tuple

log: Incomplete

class Anvil1444Interface(ParentInterface):
    """
    Moved TerrainPopulated and LightPopulated to Status
    Made blocks paletted
    Added more tick tags
    Added structures tag
    """
    TerrainPopulated: Incomplete
    LightPopulated: Incomplete
    Status: ChunkPathType
    ToBeTicked: ChunkPathType
    LiquidTicks: ChunkPathType
    LiquidsToBeTicked: ChunkPathType
    PostProcessing: ChunkPathType
    Structures: ChunkPathType
    LongArrayDense: bool
    def __init__(self) -> None: ...
    @staticmethod
    def minor_is_valid(key: int): ...
    def _decode_status(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_block_section(self, section: CompoundTag) -> Optional[Tuple[numpy.ndarray, list]]: ...
    def _decode_blocks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    @staticmethod
    def _decode_block_palette(palette: ListTag) -> list: ...
    @staticmethod
    def _decode_to_be_ticked(ticks: ListTag, floor_cy: int) -> Set[BlockCoordinates]: ...
    def _decode_block_ticks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_fluid_ticks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, __): ...
    def _decode_post_processing(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _decode_structures(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_status(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_inhabited_time(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_block_section(self, chunk: Chunk, sections: Dict[int, CompoundTag], palette: AnyNDArray, cy: int) -> bool: ...
    @staticmethod
    def _encode_block_palette(blockstates: Iterable[Block]) -> ListTag: ...
    @staticmethod
    def _encode_to_be_ticked(ticks: Set[BlockCoordinates], floor_cy: int, height_cy: int) -> ListTag: ...
    def _encode_block_ticks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_fluid_ticks(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_post_processing(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
    def _encode_structures(self, chunk: Chunk, data: ChunkDataType, floor_cy: int, height_cy: int): ...
export = Anvil1444Interface
