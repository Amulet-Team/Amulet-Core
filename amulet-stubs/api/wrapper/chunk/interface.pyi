import abc
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from amulet.api.chunk import Chunk as Chunk
from amulet.api.data_types import AnyNDArray as AnyNDArray, VersionIdentifierType as VersionIdentifierType, VersionNumberAny as VersionNumberAny
from amulet.api.wrapper import Translator as Translator
from amulet.block_entity import BlockEntity as BlockEntity
from amulet.entity import Entity as Entity
from amulet_nbt import AbstractBaseTag, AnyNBT as AnyNBT, CompoundTag, ListTag, NamedTag
from enum import Enum
from typing import Any, Callable, Optional, Sequence, Tuple, Type, Union, overload

class EntityIDType(Enum):
    int_id: int
    str_id: int
    namespace_str_id: int
    namespace_str_Id: int
    namespace_str_identifier: int

class EntityCoordType(Enum):
    xyz_int: int
    Pos_list_float: int
    Pos_list_double: int
    Pos_list_int: int
    Pos_array_int: int

PosTypeMap: Incomplete

class Interface(ABC, metaclass=abc.ABCMeta):
    @abstractmethod
    def decode(self, *args, **kwargs) -> Tuple['Chunk', AnyNDArray]: ...
    def _decode_entity(self, nbt: NamedTag, id_type: EntityIDType, coord_type: EntityCoordType) -> Optional[Entity]: ...
    def _decode_block_entity(self, nbt: NamedTag, id_type: EntityIDType, coord_type: EntityCoordType) -> Optional[BlockEntity]: ...
    @staticmethod
    def _decode_base_entity(named_tag: NamedTag, id_type: EntityIDType, coord_type: EntityCoordType) -> Optional[Tuple[str, str, Union[int, float], Union[int, float], Union[int, float], NamedTag]]: ...
    @abstractmethod
    def encode(self, *args, **kwargs) -> Any:
        """
        Take a version-specific chunk and encode it to raw data for the format to store.
        """
    def _encode_entity(self, entity: Entity, id_type: EntityIDType, coord_type: EntityCoordType) -> Optional[NamedTag]: ...
    def _encode_block_entity(self, entity: BlockEntity, id_type: EntityIDType, coord_type: EntityCoordType) -> Optional[NamedTag]: ...
    @staticmethod
    def _encode_base_entity(entity: Union[Entity, BlockEntity], id_type: EntityIDType, coord_type: EntityCoordType) -> Optional[NamedTag]: ...
    @overload
    @staticmethod
    def check_type(obj: CompoundTag, key: str, dtype: Type[AnyNBT]) -> bool: ...
    @overload
    @staticmethod
    def check_type(obj: ListTag, key: int, dtype: Type[AnyNBT]) -> bool: ...
    @overload
    def get_obj(self, obj: CompoundTag, key: str, dtype: Type[AnyNBT], default: Optional[AnyNBT] = ...) -> Optional[AnyNBT]: ...
    @overload
    def get_obj(self, obj: ListTag, key: int, dtype: Type[AnyNBT], default: Optional[AnyNBT] = ...) -> Optional[AnyNBT]: ...
    def get_nested_obj(self, obj: Union[CompoundTag, ListTag], path: Sequence[Tuple[Union[str, int], Type[AbstractBaseTag]]], default: Union[None, AnyNBT, Callable[[], Any]] = ..., *, pop_last: bool = ...):
        """
        Get an object from a nested NBT structure

        :param obj: The root NBT object
        :param path: The path to the desired object (key, dtype)
        :param default: The default value to use if the existing is not valid. If default is callable then return the called result.
        :param pop_last: If true the last key will be popped
        :return:
        """
    @staticmethod
    def set_obj(obj: CompoundTag, key: str, dtype: Type[AnyNBT], default: Union[None, AnyNBT, Callable[[], Any]] = ..., path: Sequence[str] = ..., *, setdefault: bool = ...) -> AnyNBT:
        """
        Works like setdefualt on a dictionary but works with an optional nested path.

        :param obj: The compound tag to get the data from
        :param key: The key to setdefault
        :param dtype: The dtype that the key must be
        :param default: The default value to set if it does not exist or the type is wrong
        :param path: Optional path to the nested compound.
        :param setdefault: If True will behave like setdefault. If False will replace existing data.
        :return: The data at the path
        """
    @abstractmethod
    def get_translator(self, max_world_version: VersionIdentifierType, data: Any = ...) -> Tuple['Translator', VersionNumberAny]:
        """
        Get the Translator class for the requested version.
        :param max_world_version: The game version the world was last opened in. Version number tuple or data version number.
        :param data: Optional data to get translator based on chunk version rather than world version
        :return: Tuple[Translator, version number for PyMCTranslate to use]
        """
    @staticmethod
    @abstractmethod
    def is_valid(key: Tuple) -> bool:
        """
        Returns whether this Interface is able to interface with the chunk type with a given identifier key,
        generated by the format.

        :param key: The key who's decodability needs to be checked.
        :return: True if this interface can interface with the chunk version associated with the key, False otherwise.
        """
