from abc import ABC
from collections.abc import Hashable, Sequence
from typing import Any, Callable, Concatenate, ParamSpec, Protocol, TypeVar, overload

from _typeshed import Incomplete

class AbstractArg(ABC):
    """The base class for all arguments."""

class AbstractHashableArg(AbstractArg, ABC):
    """A base class for all arguments that are hashable."""

class DocumentationArg(AbstractArg):
    """A way to add documentation for an argument."""

    arg: Incomplete
    name: Incomplete
    description: Incomplete
    def __init__(
        self, arg: AbstractArg, name: str | None = None, description: str | None = None
    ) -> None:
        """Construct a DocumentationArg instance.

        :param arg: The argument this documentation relates to.
        :param name: The short name for the argument.
        :param description: A longer description for the argument.
        """

class ConstantArg(AbstractArg):
    """A constant argument.
    Use this for fixed values.
    """

    value: Incomplete
    def __init__(self, value: Any) -> None: ...

class StringArg(AbstractHashableArg):
    """A string argument"""

    default: Incomplete
    def __init__(self, default: str) -> None: ...

class FilePathArg(StringArg):
    """A path to a file on disk. Converts to a string."""

class DirectoryPathArg(StringArg):
    """A path to a directory on disk. Converts to a string."""

class BytesArg(AbstractHashableArg):
    """A bytes argument"""

    default: Incomplete
    def __init__(self, default: bytes = b"") -> None: ...

class BoolArg(AbstractHashableArg):
    """A bool argument"""

    default: Incomplete
    def __init__(self, default: bool = False) -> None: ...

class IntArg(AbstractHashableArg):
    """An int argument"""

    default: Incomplete
    min_value: Incomplete
    max_value: Incomplete
    def __init__(
        self,
        default: int = 0,
        min_value: int | None = None,
        max_value: int | None = None,
    ) -> None: ...

class FloatArg(AbstractHashableArg):
    """A float argument"""

    default: Incomplete
    min_value: Incomplete
    max_value: Incomplete
    def __init__(
        self,
        default: float = 0,
        min_value: float | None = None,
        max_value: float | None = None,
    ) -> None: ...

class TupleArg(AbstractArg):
    """A tuple argument"""

    args: Incomplete
    def __init__(self, *args: AbstractArg) -> None: ...

class HashableTupleArg(AbstractArg):
    """A tuple argument where all elements are hashable."""

    args: Incomplete
    def __init__(self, *args: AbstractHashableArg) -> None: ...

class SequenceArg(AbstractArg):
    """
    A sequence of other arguments.
    Each element must match element_type.
    length must be a positive integer for a fixed length or None for unbounded length.
    """

    element_type: Incomplete
    default: Incomplete
    min_length: Incomplete
    max_length: Incomplete
    def __init__(
        self,
        element_type: AbstractArg,
        default: Sequence[AbstractArg] = (),
        min_length: int | None = None,
        max_length: int | None = None,
    ) -> None: ...

class PositionalArgs(SequenceArg):
    """A sequence of arguments that should be unpacked into the container.
    This is useful when a CallableArg can take a variable number of an argument.
    """

class DictArg(AbstractArg):
    """A dictionary argument"""

    key: Incomplete
    value: Incomplete
    def __init__(self, key: AbstractHashableArg, value: AbstractArg) -> None: ...

class UnionArg(AbstractArg):
    """The object must match one of the types in args"""

    args: Incomplete
    def __init__(self, *args: AbstractArg) -> None: ...

class HashableUnionArg(AbstractArg):
    """The object must match one of the types in args"""

    args: Incomplete
    def __init__(self, *args: AbstractHashableArg) -> None: ...

class CallableArg(AbstractArg):
    """An argument generated by a function.
    This can be used to create instances of classes.
    kwargs specify the arguments to pass to the function.
    """

    func: Incomplete
    call_spec: Incomplete
    def __init__(
        self, func: Callable[..., Any], *args: AbstractArg, **kwargs: AbstractArg
    ) -> None: ...

class HashableCallableArg(AbstractHashableArg):
    """An argument generated by a function.
    This can be used to create instances of classes.
    kwargs specify the arguments to pass to the function.
    """

    func: Incomplete
    call_spec: Incomplete
    def __init__(self, func: Callable[..., Hashable], call_spec: CallSpec) -> None: ...

class CallSpec:
    """Arguments and keyword arguments that should be unpacked to call a function."""

    args: Incomplete
    kwargs: Incomplete
    def __init__(self, *args: AbstractArg, **kwargs: AbstractArg) -> None: ...

P = ParamSpec("P")
R = TypeVar("R", covariant=True)

class TypedCallable(Protocol[P, R]):
    call_spec: CallSpec
    def __call__(self, *args: P.args, **kwargs: P.kwargs) -> R: ...

class TypedMethod(Protocol[P, R]):
    call_spec: CallSpec
    def __call__(self, self_: Any, *args: P.args, **kwargs: P.kwargs) -> R: ...
    @overload
    def __get__(self, instance: None, owner: None) -> TypedMethod[P, R]: ...
    @overload
    def __get__(self, instance: object, owner: object) -> TypedCallable[P, R]: ...

def callable_spec(
    *args: AbstractArg, **kwargs: AbstractArg
) -> Callable[[Callable[P, R]], TypedCallable[P, R]]: ...
def method_spec(
    *args: AbstractArg, **kwargs: AbstractArg
) -> Callable[[Callable[Concatenate[Any, P], R]], TypedMethod[P, R]]: ...
